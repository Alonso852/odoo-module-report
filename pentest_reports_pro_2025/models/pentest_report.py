from odoo import _, api, fields, models


class PentestReport(models.Model):
    """Main model that stores the pentest summary and related sections."""

    _name = "pentest.report"
    _description = "Pentest Report"
    _inherit = ["mail.thread", "mail.activity.mixin"]
    _order = "create_date desc"

    name = fields.Char(
        string="Title",
        required=True,
        tracking=True,
        help="Human friendly title that is shown to the customer.",
    )
    reference = fields.Char(
        string="Reference",
        default="New",
        copy=False,
        readonly=True,
        required=True,
        index=True,
        help="Unique identifier generated from the pentest sequence.",
    )
    client = fields.Char(
        string="Client",
        required=True,
        tracking=True,
        help="Customer or project concerned by the report.",
    )
    status = fields.Selection(
        selection=[
            ("draft", "Draft"),
            ("review", "In Review"),
            ("approved", "Approved"),
            ("published", "Published"),
        ],
        string="Status",
        default="draft",
        tracking=True,
        required=True,
        help="Workflow state that controls what can be done with the report.",
    )
    confidentiality = fields.Selection(
        selection=[
            ("public", "Public"),
            ("internal", "Internal"),
            ("confidential", "Confidential"),
            ("strictly_confidential", "Strictly Confidential"),
        ],
        string="Confidentiality",
        default="internal",
        required=True,
        tracking=True,
        help="Confidentiality label printed on exported documents.",
    )
    company_id = fields.Many2one(
        "res.company",
        string="Company",
        required=True,
        default=lambda self: self.env.company,
        index=True,
        help="Company that owns the report.",
    )
    authors = fields.Many2many(
        "res.users",
        string="Authors",
        tracking=True,
        default=lambda self: [(4, self.env.user.id)],
        help="Consultants responsible for the pentest delivery.",
    )
    version = fields.Integer(
        string="Version",
        default=1,
        copy=False,
        tracking=True,
        help="Automatically increased whenever the content is updated.",
    )
    section_ids = fields.One2many(
        "pentest.section",
        "report_id",
        string="Sections",
        copy=True,
        help="All sections that compose the report.",
    )
    section_count = fields.Integer(
        string="Section Count",
        compute="_compute_section_metrics",
        help="Technical field used by the smart button.",
    )
    attachment_ids = fields.Many2many(
        "ir.attachment",
        compute="_compute_section_metrics",
        string="Image Attachments",
        help="Attachments linked to the sections of the report.",
    )
    attachment_count = fields.Integer(
        string="Attachment Count",
        compute="_compute_section_metrics",
        help="Number of image attachments present in the report.",
    )
    active = fields.Boolean(default=True)

    _sql_constraints = [
        ("reference_unique", "unique(reference, company_id)", "The reference must be unique per company."),
    ]

    @api.depends("section_ids", "section_ids.image_id")
    def _compute_section_metrics(self):
        for report in self:
            attachments = report.section_ids.mapped("image_id").filtered(lambda attachment: attachment)
            report.attachment_ids = attachments
            report.attachment_count = len(attachments)
            report.section_count = len(report.section_ids)

    def action_export_pdf(self):
        """Generate the official PDF report using the QWeb template."""

        self.ensure_one()
        return self.env.ref("pentest_reports_pro_2025.action_report_pentest").report_action(self)

    def action_preview(self):
        """Display the report content as HTML using the same QWeb template."""

        self.ensure_one()
        return {
            "type": "ir.actions.report",
            "report_type": "qweb-html",
            "report_name": "pentest_reports_pro_2025.report_pentest_qweb_preview",
            "res_id": self.id,
        }

    def action_view_sections(self):
        """Open the section records linked to the report."""

        self.ensure_one()
        action = self.env.ref("pentest_reports_pro_2025.action_pentest_section").read()[0]
        action["domain"] = [("report_id", "=", self.id)]
        action["context"] = {
            "default_report_id": self.id,
        }
        return action

    def action_view_attachments(self):
        """Open the attachments window filtered on the current report."""

        self.ensure_one()
        action = self.env.ref("base.action_attachment").read()[0]
        action["domain"] = [("res_model", "=", self._name), ("res_id", "=", self.id)]
        action["context"] = {
            "default_res_model": self._name,
            "default_res_id": self.id,
        }
        return action

    @api.model_create_multi
    def create(self, vals_list):
        sequence = self.env["ir.sequence"]
        for vals in vals_list:
            if vals.get("reference", "New") == "New":
                vals["reference"] = sequence.next_by_code("pentest.report") or _("New Report")
        reports = super(PentestReport, self.with_context(skip_section_version=True)).create(vals_list)
        for report in reports:
            if not report.authors:
                report.authors = [(4, self.env.user.id)]
        return reports

    def write(self, vals):
        if self.env.context.get("skip_version_increment"):
            return super().write(vals)

        tracked_fields = {"name", "client", "section_ids", "status", "confidentiality"}
        res = super().write(vals)
        if tracked_fields.intersection(vals):
            self._bump_version()
        return res

    def copy_data(self, default=None):
        default = dict(default or {})
        default.setdefault("version", 1)
        default.setdefault("reference", "New")
        return super().copy_data(default)

    def _bump_version(self):
        if self.env.context.get("skip_section_version"):
            return
        for record in self:
            record.with_context(skip_version_increment=True, skip_section_version=True).write({"version": record.version + 1})
